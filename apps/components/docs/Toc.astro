---
import type { MarkdownHeading } from 'astro';
import { generateToc, type TocEntry } from '../../libs/toc';

interface Props {
  headings?: MarkdownHeading[];
  entries?: TocEntry[];
}

const { entries, headings } = Astro.props;
const toc = entries ? entries : generateToc(headings ?? []);
---

<ul id="toc-root" class="ps-4 list-none" data-header-offset="96">
  {
    toc.map(({ children, slug, text }) => (
      <li>
        <a
          href={`#${slug}`}
          id={`toc-${slug}`}
          data-target-id={slug}
          class="no-underline flex items-center flex-nowrap gap-3 py-1 mb-1 text-sm text-highlight aria-[current=true]:text-primary aria-[current=true]:font-medium"
        >
          <span class="w-1 h-1 rounded-full bg-current" />
          {text}
        </a>
        {children.length > 0 && <Astro.self entries={children} />}
      </li>
    ))
  }
</ul>

<script>
  (() => {
    const tocRoot = document.getElementById('toc-root') as HTMLUListElement | null;
    if (!tocRoot) return;

    const anchors = Array.from(tocRoot.querySelectorAll<HTMLAnchorElement>('a[data-target-id]'));

    interface Item {
      id: string;
      el: HTMLElement;
      a: HTMLAnchorElement;
    }

    const items: Item[] = anchors
      .map((a) => {
        const id = a.dataset.targetId ?? '';
        const el = id ? (document.getElementById(id) as HTMLElement | null) : null;
        return el ? { id, el, a } : null;
      })
      .filter((x): x is Item => Boolean(x));

    if (!items.length) return;

    const HEADER_OFFSET = Number.parseInt(tocRoot.dataset.headerOffset ?? '', 10) || 96;

    // Click handling (no smooth scroll)
    anchors.forEach((a) => {
      a.addEventListener('click', (e) => {
        const id = a.dataset.targetId;
        const target = id ? document.getElementById(id) : null;
        if (!target) return;
        e.preventDefault();

        const y = target.getBoundingClientRect().top + window.scrollY - HEADER_OFFSET;
        window.history.pushState(null, '', `#${id}`);
        // Instant jump (no smooth behavior)
        window.scrollTo({ top: y });
      });
    });

    const clearAll = () => anchors.forEach((x) => x.setAttribute('aria-current', 'false'));

    const bubbleToParents = (anchor: HTMLAnchorElement) => {
      let li = anchor.closest('li') as HTMLLIElement | null;
      while (li) {
        const parentAnchor = li.querySelector<HTMLAnchorElement>(':scope > a[data-target-id]');
        if (parentAnchor) parentAnchor.setAttribute('aria-current', 'true');
        li = li.parentElement?.closest('li') ?? null;
      }
    };

    const setActive = (id: string) => {
      clearAll();
      const activeAnchor = anchors.find((x) => x.dataset.targetId === id);
      if (activeAnchor) {
        activeAnchor.setAttribute('aria-current', 'true');
        bubbleToParents(activeAnchor);
      }
    };

    // Initialize from hash (if present)
    if (location.hash) {
      const hashId = decodeURIComponent(location.hash.slice(1));
      if (anchors.some((a) => a.dataset.targetId === hashId)) {
        setActive(hashId);
      }
    }

    // Pick the "current" heading based on scroll position
    const chooseByScroll = () => {
      const above = items.filter(({ el }) => el.getBoundingClientRect().top - HEADER_OFFSET <= 0);
      const current = above.length ? above[above.length - 1] : items[0];
      if (current) setActive(current.id);
    };

    // IntersectionObserver for efficiency + better edge handling
    const io = new IntersectionObserver(
      () => {
        // On any intersection change, update using scroll heuristic for accuracy
        requestAnimationFrame(chooseByScroll);
      },
      {
        root: null,
        rootMargin: `-${HEADER_OFFSET}px 0px -70% 0px`,
        threshold: [0, 1],
      },
    );

    items.forEach(({ el }) => io.observe(el));

    let ticking = false;
    window.addEventListener(
      'scroll',
      () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            chooseByScroll();
            ticking = false;
          });
          ticking = true;
        }
      },
      { passive: true },
    );

    window.addEventListener('resize', () => {
      // Re-evaluate which heading is current after layout shifts
      requestAnimationFrame(chooseByScroll);
    });

    // Initial highlight
    chooseByScroll();
  })();
</script>
