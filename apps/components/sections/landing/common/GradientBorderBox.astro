---
interface Props {
  color: string;
  class?: string;
}

const { color, class: className = '' } = Astro.props;
---

<div class={`gradient-border gradient-border-${color} rotate-on-hover ${className}`}>
  <slot />
</div>

<script type="module">
  if (!window.__GradientCardHoverInit) {
    window.__GradientCardHoverInit = true;

    const DEFAULT_SPEED = 90;
    const RESET_DURATION = 1000;

    function initElement(el) {
      if (!el || el.dataset.gradientInit === true) return;
      el.dataset.gradientInit = true;

      let angle = 118.65;
      const speedAttr = el.dataset.gradientSpeed;
      const speed = (speedAttr ? parseFloat(speedAttr) : NaN) || DEFAULT_SPEED;

      let running = false;
      let rafId = null;
      let lastTime = 0;

      function frame(now) {
        if (!running) {
          rafId = null;
          return;
        }
        if (!lastTime) lastTime = now;
        const dt = (now - lastTime) / 1000;
        lastTime = now;
        angle = (angle + speed * dt) % 360;
        el.style.setProperty('--gradient-angle', angle + 'deg');
        rafId = requestAnimationFrame(frame);
      }

      function start() {
        if (running) return;
        running = true;
        lastTime = 0;
        if (!rafId) rafId = requestAnimationFrame(frame);
      }

      function stop() {
        running = false;
        lastTime = 0;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }

        const startAngle = angle;
        const endAngle = 118.65;
        const startTime = performance.now();

        function resetStep(now) {
          const t = Math.min((now - startTime) / RESET_DURATION, 1);
          const newAngle = startAngle + (endAngle - startAngle) * t;
          el.style.setProperty('--gradient-angle', newAngle + 'deg');
          if (t < 1) requestAnimationFrame(resetStep);
          else angle = endAngle;
        }
        requestAnimationFrame(resetStep);
      }

      el.addEventListener('pointerenter', start, { passive: true });
      el.addEventListener('pointerleave', stop, { passive: true });
      el.addEventListener('pointercancel', stop, { passive: true });
      el.addEventListener('focus', start);
      el.addEventListener('blur', stop);
    }

    document.querySelectorAll('.rotate-on-hover').forEach(initElement);

    const mo = new MutationObserver((mutations) => {
      for (const m of mutations) {
        for (const node of m.addedNodes) {
          if (!(node instanceof HTMLElement)) continue;
          if (node.matches?.('.rotate-on-hover')) initElement(node);
          node.querySelectorAll?.('.rotate-on-hover').forEach(initElement);
        }
      }
    });
    mo.observe(document.documentElement || document.body, { childList: true, subtree: true });
  }
</script>
