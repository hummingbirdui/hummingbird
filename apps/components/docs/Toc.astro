---
import type { MarkdownHeading } from 'astro';
import { generateToc, type TocEntry } from '../../libs/toc';

interface Props {
  headings?: MarkdownHeading[];
  entries?: TocEntry[];
}

const { entries, headings } = Astro.props;
const toc = entries ? entries : generateToc(headings ?? []);
---

<ul id="toc-root" class="ps-4 list-none" data-header-offset="120">
  {
    toc.map(({ children, slug, text }) => (
      <li>
        <a
          href={`#${slug}`}
          id={`toc-${slug}`}
          data-target-id={slug}
          class="no-underline flex items-center flex-nowrap gap-3 py-1 mb-1 text-sm text-highlight aria-[current=true]:text-primary aria-[current=true]:font-medium"
        >
          <span class="w-1 h-1 rounded-full bg-current" />
          {text}
        </a>
        {children.length > 0 && <Astro.self entries={children} />}
      </li>
    ))
  }
</ul>

<script>
  (() => {
    const tocRoot = document.getElementById('toc-root') as HTMLUListElement | null;
    if (!tocRoot) return;

    const HEADER_OFFSET = Number.parseInt(tocRoot.dataset.headerOffset || '120', 10) || 120;

    const SCROLL_SELECTOR = tocRoot.dataset.scrollContainer || '';
    type Scrollable = Window | HTMLElement;

    const maybeContainer = SCROLL_SELECTOR ? (document.querySelector(SCROLL_SELECTOR) as HTMLElement | null) : null;

    const scrollContainer: Scrollable = maybeContainer ?? window;

    const isWindow = (x: Scrollable): x is Window => x === window;

    const anchors = Array.from(tocRoot.querySelectorAll<HTMLAnchorElement>('a[data-target-id]'));

    type Item = { id: string; el: HTMLElement; a: HTMLAnchorElement };

    const items: Item[] = anchors
      .map((a) => {
        const id = a.dataset.targetId;
        if (!id) return null;
        const el = document.getElementById(id) as HTMLElement | null;
        return el ? { id, el, a } : null;
      })
      .filter((x): x is Item => x !== null);

    if (items.length === 0) return;

    const clearAll = () => anchors.forEach((a) => a.setAttribute('aria-current', 'false'));

    const bubbleToParents = (anchor: HTMLAnchorElement) => {
      let li = anchor.closest('li') as HTMLLIElement | null;
      while (li) {
        const parentAnchor = li.querySelector<HTMLAnchorElement>(':scope > a[data-target-id]');
        if (parentAnchor) parentAnchor.setAttribute('aria-current', 'true');
        const parentList = li.parentElement;
        li = parentList ? parentList.closest('li') : null;
      }
    };

    const setActive = (id: string) => {
      clearAll();
      const active = anchors.find((a) => a.dataset.targetId === id);
      if (active) {
        active.setAttribute('aria-current', 'true');
        bubbleToParents(active);
      }
    };

    const getScrollTop = (): number =>
      isWindow(scrollContainer) ? scrollContainer.scrollY : scrollContainer.scrollTop;

    const getContainerTop = (): number => (isWindow(scrollContainer) ? 0 : scrollContainer.getBoundingClientRect().top);

    // Absolute Y within the *scrolling context*
    const absY = (el: HTMLElement): number => {
      const rect = el.getBoundingClientRect();
      if (isWindow(scrollContainer)) {
        return rect.top + window.scrollY;
      }
      return rect.top - getContainerTop() + scrollContainer.scrollTop;
    };

    // Click: activate right away and scroll the correct container
    anchors.forEach((a) => {
      a.addEventListener('click', (e) => {
        const id = a.dataset.targetId;
        if (!id) return;

        const target = document.getElementById(id) as HTMLElement | null;
        if (!target) return;

        e.preventDefault();
        setActive(id);

        const y = absY(target) - HEADER_OFFSET;
        history.pushState(null, '', `#${id}`);

        if (isWindow(scrollContainer)) {
          window.scrollTo({ top: y });
        } else {
          scrollContainer.scrollTo({ top: y });
        }
      });
    });

    // Scroll-driven activation
    const EPS = 1;
    const chooseByScroll = () => {
      const currentTop = getScrollTop();
      let current: Item | undefined = items[0];

      for (const it of items) {
        if (absY(it.el) - currentTop - HEADER_OFFSET <= EPS) {
          current = it;
        } else {
          break;
        }
      }
      if (current) setActive(current.id);
    };

    // Keep in sync on back/forward & manual edits
    window.addEventListener('hashchange', () => {
      const raw = location.hash.slice(1);
      if (!raw) return;
      const id = decodeURIComponent(raw);
      if (anchors.some((a) => a.dataset.targetId === id)) setActive(id);
    });

    // rAF-throttled scroll handler
    let ticking = false;
    const onScroll: EventListener = () => {
      if (ticking) return;
      ticking = true;
      requestAnimationFrame(() => {
        chooseByScroll();
        ticking = false;
      });
    };

    if (isWindow(scrollContainer)) {
      window.addEventListener('scroll', onScroll, { passive: true });
    } else {
      scrollContainer.addEventListener('scroll', onScroll, { passive: true });
    }

    window.addEventListener('resize', () => {
      requestAnimationFrame(chooseByScroll);
    });

    // Initial state
    if (location.hash) {
      const raw = location.hash.slice(1);
      if (raw) {
        const hashId = decodeURIComponent(raw);
        if (anchors.some((a) => a.dataset.targetId === hashId)) {
          setActive(hashId);
        } else {
          chooseByScroll();
        }
      } else {
        chooseByScroll();
      }
    } else {
      chooseByScroll();
    }
  })();
</script>
